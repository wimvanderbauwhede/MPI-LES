This is an example of reducing memory by eliminating intermediate arrays.

The code is based on one of the key algorithms in the Large Eddy Simulator for Urban Flows.

The simulator performs the following actions at every timestep (the number in parentheses is the number of full-domain 3-D arrays used):
- Set initial boundary conditions for wind velocity and pressure (4)
- Calculate the turbulent flow using the marker-and-cell method: based on the velocity fields u,v,w calculate the convection components and from this calculates the force fields f,g,h. (37)
- Integrate the force fields over time (Adams-Bashfort) (6)
- Solve the Poisson equation for the pressure using successive over-relatation (6)

In the original code, the turbulent flow algorithm uses the following 3-D arrays, 37 in total:

u,v,w
f,g,h
diu 1..9 for partial derivatives of the velocity
nou 1..9 for interpolated values
cov 1..9 for convection components
df{u,v,w}1 for updating the force fields with their derivatives 
sm 

Of these 37 arrays, only u,v,w are actual inputs to the calculation and f,g,h computed outputs. 

Our memory reduction approach eliminates the 31 intermediate arrays entirely. In the other algorithms, there are no redundant arrays. 

To illustrate the impact: assuming the GPU has 4GB of memory, then the maximum domain  for the original code was 100 MB, which translates to a domain of about 400x400 points.
After removal of the intermediate arrays, the domain can be up to 1000x1000 points.
As all redundant array accesses are replace by register accesses in the GPU, the resulting code is not only more memory efficient but also faster.

The work flow is as follows:
1. In ~/Research/DPRI/LEScode/OriginalSourcesF77: run `refactorF4Acc.pl -c ../rf4a.cfg`
    This will generated refactored code in RefactoredSourcesV11
2. In ~/Git/MPI-LES: run `./copy_refactored_src_from_OriginalSourcesF77.sh`
    This will copy the refactored sources in to src-for_MemoryReduction
3. In ~/Git/MPI-LES: run `perl aux/generate_and_build_OpenCL_version.pl --stage autopar --srcdir src-for_MemoryReduction --refsrcdir generated-src-for_MemoryReduction`
4. In ~/Git/MPI-LES/generated-src-for_MemoryReduction:
    `mkdir Work`
    `cp module_adam_bondv1_feedbf_les_press_v_etc_superkernel.f95 Work`
5. In ~/Git/MPI-LES/generated-src-for_MemoryReduction/Work:
    - Manually edit the file to remove anything that wil not work
    - run `memory_reduction.pl`. This should create the reduced file
6. In ~/Git/MPI-LES/generated-src-for_MemoryReduction/Work/MemoryReduction/Generated:
    - Compile to code to see if it works
    `scons`
7. In ~/Git/MPI-LES/generated-src-for_MemoryReduction/Work/MemoryReduction/:
    - Run the inliner
    `refactorF4Acc.pl -c ./rf4a_inline.cfg`
    - Remove redundant files
    `rm f_*.f95 velfg_map_*.f95 module_*`
    - Copy over the scalarised files
    `cp MemoryReduction/Scalarized/velfg_map_*.f95 mem_reduced_inlined/Generated/`
    - Patch the generated code as it is broken
    `perl ../aux/patch_inlined_code.pl`
7. TODO create a code to drive this and compare with the original version    

It looks like I actually did a better version in  ~/Git/MPI-LES/generated-src-for_MemoryReduction/Work but still needs to run the inliner.
The inliner will run if there are !$RF4A Inline pragmas. These are generated by `MemoryReduction-exe` 

See `/home/wim/Git/RefactorF4Acc/tests/SOR_unroll/aux/generate_and_build_OpenCL_version.pl`, 

refactorF4acc.pl '.$vflag.' -c rf4a_inline.cfg

# Create `rf4a_inline.cfg` 
    my $rf4a_inline = <<ENDCFG;
# Relative path to the original Fortran source code
SRCDIRS = Generated
# Relative path to the refactored Fortran source code
NEWSRCPATH = ../../mem_reduced_inlined$suffix
# Name of the subroutine to start from. If this is the main program, leave blank.
# TOP = 
EXT = .f95
RENAME_PARS_IN_INLINED_SUBS = 0
RENAME_VARS_IN_INLINED_SUBS = 0
ONE_SUB_PER_MODULE = 0
ENDCFG

    open my $CFG, '>', 'rf4a_inline.cfg';
    print $CFG $rf4a_inline;
    close $CFG;

    say($ENV{HOME}.'/Git/RefactorF4Acc/bin/'.'refactorF4acc.pl '.$vflag.' -c rf4a_inline.cfg');
    system($ENV{HOME}.'/Git/RefactorF4Acc/bin/'.'refactorF4acc.pl '.$vflag.' -c rf4a_inline.cfg');

So, in Work/MemoryReduction I did the following:

* In Scalarised:
  - edited the files to add parameter declarations, 
  - then ran `gfortran -ffree-line-length-0 -c velfg_map_*.f95` to create `.mod` files
* In Generated  
  - edited `module_gen_velfg_superkernel.f95` because some scalars have an Intent but they are not toplevel args. Size was only 47K, 562 loc
  - Compiling with `gfortran -Ofast -ffree-line-length-0 -c module_velfg_superkernel.f95` (after manual removal of incorrect Intents) gives a 13K .o 

  - then ran `gfortran -I ../Scalarized/ -ffree-line-length-0 -c module_gen_velfg_superkernel.f95`
  - This generates a 15K .mod and a 171K .o file, no errors
* In Work/MemoryReduction
- `mkdir ../mem_reduced_inlined`
- created the `rf4a_inline.cfg`  file
- `refactorF4acc.pl -c ./rf4a_inline.cfg` => LOTS of warnings!
- `rm ../mem_reduced_inlined/Generated/f_*`
- `rm ../mem_reduced_inlined/Generated/module_gen_velfg_superkernel.f95`
- Final result is in `../mem_reduced_inlined/Generated/stage_kernel_1.f95`
- Size is 87K, 2796 loc;
- Compiling with `gfortran -Ofast -ffree-line-length-0 -c stage_kernel_1.f95` generates a 54K .o (same for -O3; -O2 51K; -O1 64K)

There is still some things wrong with the generated code, in particular the generated module names for the scalarised functions.
See `aux/patch_inlined_code.pl` for the fixes.

The `stage_kernel_1` generated with unique names is 218K, 4652 loc (the original is 47K, 562 loc)

